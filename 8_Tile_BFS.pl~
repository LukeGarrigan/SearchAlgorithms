
goal(1/2/3/4/5/6/7/8/0).

left( A/0/C/D/E/F/H/I/J , 0/A/C/D/E/F/H/I/J ).
left( A/B/C/D/0/F/H/I/J , A/B/C/0/D/F/H/I/J ).
left( A/B/C/D/E/F/H/0/J , A/B/C/D/E/F/0/H/J ).
left( A/B/0/D/E/F/H/I/J , A/0/B/D/E/F/H/I/J ).
left( A/B/C/D/E/0/H/I/J , A/B/C/D/0/E/H/I/J ).
left( A/B/C/D/E/F/H/I/0 , A/B/C/D/E/F/H/0/I ).

up( A/B/C/0/E/F/H/I/J , 0/B/C/A/E/F/H/I/J ).
up( A/B/C/D/0/F/H/I/J , A/0/C/D/B/F/H/I/J ).
up( A/B/C/D/E/0/H/I/J , A/B/0/D/E/C/H/I/J ).
up( A/B/C/D/E/F/0/I/J , A/B/C/0/E/F/D/I/J ).
up( A/B/C/D/E/F/H/0/J , A/B/C/D/0/F/H/E/J ).
up( A/B/C/D/E/F/H/I/0 , A/B/C/D/E/0/H/I/F ).

right( A/0/C/D/E/F/H/I/J , A/C/0/D/E/F/H/I/J ).
right( A/B/C/D/0/F/H/I/J , A/B/C/D/F/0/H/I/J ).
right( A/B/C/D/E/F/H/0/J , A/B/C/D/E/F/H/J/0 ).
right( 0/B/C/D/E/F/H/I/J , B/0/C/D/E/F/H/I/J ).
right( A/B/C/0/E/F/H/I/J , A/B/C/E/0/F/H/I/J ).
right( A/B/C/D/E/F/0/I/J , A/B/C/D/E/F/I/0/J ).

down( A/B/C/0/E/F/H/I/J , A/B/C/H/E/F/0/I/J ).
down( A/B/C/D/0/F/H/I/J , A/B/C/D/I/F/H/0/J ).
down( A/B/C/D/E/0/H/I/J , A/B/C/D/E/J/H/I/0 ).
down( 0/B/C/D/E/F/H/I/J , D/B/C/0/E/F/H/I/J ).
down( A/0/C/D/E/F/H/I/J , A/E/C/D/0/F/H/I/J ).
down( A/B/0/D/E/F/H/I/J , A/B/F/D/E/0/H/I/J ).

move(P,C,left) :-  left(P,C).
move(P,C,up) :-  up(P,C).
move(P,C,right) :-  right(P,C).
move(P,C,down) :-  down(P,C).

% Figure 11.10   An implementation of breadth-first search.


% solve( Start, Solution):
%    Solution is a path (in reverse order) from Start to a goal


%
solve( Start, Solution)  :-
  breadthfirst( [ [Start] ], Sal),
  reverse(Sal, Solution).

% solve( Start, Solution)  :-
%  breadthfirst( [ [Start] | Z] - Z, Solution).

%breadthfirst( [ [Node | Path] | _] - _, [Node | Path] )  :-
%  goal( Node).

%breadthfirst( [Path | Paths] - Z, Solution)  :-
%  extend( Path, NewPaths),
%  conc( NewPaths, Z1, Z),              % Add NewPaths at end
%  Paths \== Z1,                        % Set of candidates not empty
%  breadthfirst( Paths - Z1, Solution).

% This checks to see if the current configuration is the goal
breadthfirst( [ [Node | Path] | _], [Node | Path])  :-
  goal(Node).

% Knows that it's not a goal configuration
%


% The reason for storing all the paths is to ensure that we do not get
% stuck in a loop where we choose the same path repeatedly

breadthfirst( [Path | Paths], Solution)  :-
  extend( Path, NewPaths),            % Finds all the possibilities that haven't been chosen
  conc( Paths, NewPaths, Paths1),     % Concatenates the paths
  breadthfirst( Paths1, Solution).    % Continues with the new paths

extend( [Node | Path], NewPaths) :-
  % Finds all the possibilities that we haven't already chosen
  bagof( [NewNode, Node | Path],
	  ( move( Node, NewNode, _), not(member( NewNode, [Node | Path]
	  )) ),
         NewPaths),
  !.

extend( _, [] ).              % bagof failed: Node has no successor


conc([],L,L).
conc([H|L1],L2,[H|L3]):-
conc(L1,L2,L3).
